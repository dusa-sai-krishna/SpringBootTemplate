// ServicesProvided.java
package com.example.model;

import com.example.model.enums.Availability;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;
import java.time.LocalTime; // Import LocalTime

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "services_provided")
public class ServicesProvided {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 200)
    private String name;

    @Column(columnDefinition = "TEXT")
    private String description;

    @Column(nullable = false)
    private float price;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 50)
    private Availability availability;

    // --- NEW FIELDS ---
    @Column(name = "start_time", nullable = false)
    private LocalTime startTime;

    @Column(name = "end_time", nullable = false)
    private LocalTime endTime;

    // --- Relationships ---

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "service_category_id", nullable = false)
    private ServiceCategory serviceCategory;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "provider_id", nullable = false, referencedColumnName = "user_id")
    private ServiceProvider serviceProvider;

    // --- Timestamps ---

    @CreationTimestamp
    @Column(name = "created_at", updatable = false, nullable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;
}


---------------------------

// ServicesProvidedDto.java
package com.example.demo.dto;

import com.example.model.enums.Availability;
import jakarta.validation.constraints.*;
import java.time.LocalTime; // Import LocalTime

public record ServicesProvidedDto(
    @NotBlank(message = "Service name cannot be blank.")
    @Size(min = 3, max = 200, message = "Service name must be between 3 and 200 characters.")
    String name,

    @Size(max = 1000, message = "Description cannot be longer than 1000 characters.")
    String description,

    @NotNull(message = "Price cannot be null.")
    @Positive(message = "Price must be a positive value.")
    Float price,

    @NotNull(message = "Availability must be specified.")
    Availability availability,

    @NotNull(message = "Service Category ID cannot be null.")
    Long serviceCategoryId,

    // --- NEW FIELDS ---
    @NotNull(message = "Start time cannot be null.")
    LocalTime startTime,

    @NotNull(message = "End time cannot be null.")
    LocalTime endTime
) {
    // Note: You could add a class-level validator to ensure endTime > startTime
}


-------------------------------




// ServicesProvidedService.java
package com.example.demo.service;

import com.example.demo.dto.ServicesProvidedDto;
import com.example.demo.exception.ResourceNotFoundException;
import com.example.demo.exception.ServiceProviderNotApprovedException;
import com.example.demo.exception.ServicesProvidedNotFoundException;
import com.example.model.ServiceCategory;
import com.example.model.ServiceProvider;
import com.example.model.ServicesProvided;
import com.example.model.User;
import com.example.model.enums.ApprovalStatus;
import com.example.repository.ServiceCategoryRepository;
import com.example.repository.ServiceProviderRepository;
import com.example.repository.ServicesProvidedRepository;
import com.example.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class ServicesProvidedService {

    private final ServicesProvidedRepository servicesProvidedRepository;
    private final UserRepository userRepository;
    private final ServiceProviderRepository serviceProviderRepository;
    private final ServiceCategoryRepository serviceCategoryRepository;

    /**
     * Adds a new service for an approved provider.
     * (No logical change here, but the mapper it calls is updated)
     */
    @Transactional
    public ServicesProvidedDto addService(String providerEmail, ServicesProvidedDto serviceDto) {
        log.info("Attempting to add service '{}' for provider {}",
            serviceDto.name(), providerEmail);

        isApproved(providerEmail);
        ServiceProvider provider = findProviderByEmailOrThrow(providerEmail);
        ServiceCategory category = findCategoryByIdOrThrow(serviceDto.serviceCategoryId());

        ServicesProvided newService = toEntity(serviceDto, provider, category);
        ServicesProvided savedService = servicesProvidedRepository.save(newService);

        log.info("Successfully added service with ID {}", savedService.getId());
        return toDto(savedService);
    }

    /**
     * Updates an existing service.
     * (MODIFIED to include startTime and endTime)
     */
    @Transactional
    public ServicesProvidedDto updateService(Long serviceId, ServicesProvidedDto serviceDto) {
        log.info("Attempting to update service with ID: {}", serviceId);

        ServicesProvided existingService = findServiceByIdOrThrow(serviceId);
        ServiceCategory newCategory = findCategoryByIdOrThrow(serviceDto.serviceCategoryId());

        // Main logic: Map updates
        existingService.setName(serviceDto.name());
        existingService.setDescription(serviceDto.description());
        existingService.setPrice(serviceDto.price());
        existingService.setAvailability(serviceDto.availability());
        existingService.setServiceCategory(newCategory);

        // --- UPDATED ---
        existingService.setStartTime(serviceDto.startTime());
        existingService.setEndTime(serviceDto.endTime());

        ServicesProvided updatedService = servicesProvidedRepository.save(existingService);
        log.info("Successfully updated service with ID: {}", updatedService.getId());
        return toDto(updatedService);
    }

    /**
     * Reads a single service by its ID.
     * (No change)
     */
    @Transactional(readOnly = true)
    public ServicesProvidedDto getServiceById(Long serviceId) {
        log.info("Fetching service with ID: {}", serviceId);
        ServicesProvided service = findServiceByIdOrThrow(serviceId);
        log.info("Found service: {}", service.getName());
        return toDto(service);
    }

    /**
     * Fetches all services belonging to a specific category.
     * (No change)
     */
    @Transactional(readOnly = true)
    public List<ServicesProvidedDto> getAllServicesByCategory(Long categoryId) {
        log.info("Fetching all services for category ID: {}", categoryId);
        ServiceCategory category = findCategoryByIdOrThrow(categoryId);
        List<ServicesProvided> services = servicesProvidedRepository.findAllByServiceCategory(category);

        log.info("Found {} services for category ID: {}", services.size(), categoryId);
        return services.stream()
                .map(this::toDto)
                .collect(Collectors.toList());
    }

    /**
     * Deletes a service by its ID.
     * (No change)
     * */
    @Transactional
    public void deleteService(Long serviceId) {
        log.info("Attempting to delete service with ID: {}", serviceId);
        ServicesProvided service = findServiceByIdOrThrow(serviceId);
        servicesProvidedRepository.delete(service);
        log.info("Successfully deleted service with ID: {}", serviceId);
    }


    // --- PRIVATE HELPER & VALIDATION METHODS (No changes) ---

    private void isApproved(String email) {
        ServiceProvider provider = findProviderByEmailOrThrow(email);
        if (provider.getApprovalStatus() != ApprovalStatus.APPROVED) {
            log.warn("Service provider {} is not approved. Status: {}",
                email, provider.getApprovalStatus());
            throw new ServiceProviderNotApprovedException(
                "Service provider " + email + " is not approved to add services.");
        }
        log.debug("Provider {} is approved.", email);
    }

    private User findUserByEmailOrThrow(String email) {
        return userRepository.findByEmail(email)
            .orElseThrow(() -> {
                log.warn("User not found with email: {}", email);
                return new ResourceNotFoundException("User not found with email: " + email);
            });
    }

    private ServiceProvider findProviderByEmailOrThrow(String email) {
        User user = findUserByEmailOrThrow(email);
        return serviceProviderRepository.findById(user.getId())
            .orElseThrow(() -> {
                log.warn("ServiceProvider profile not found for user ID: {}", user.getId());
                return new ResourceNotFoundException(
                    "ServiceProvider profile not found for user: " + email);
            });
    }

    private ServiceCategory findCategoryByIdOrThrow(Long categoryId) {
        return serviceCategoryRepository.findById(categoryId)
            .orElseThrow(() -> {
                log.warn("ServiceCategory not found with ID: {}", categoryId);
                return new ResourceNotFoundException(
                    "ServiceCategory not found with ID: " + categoryId);
            });
    }

fs
    private ServicesProvided findServiceByIdOrThrow(Long serviceId) {
        return servicesProvidedRepository.findById(serviceId)
            .orElseThrow(() -> {
                log.warn("ServicesProvided not found with ID: {}", serviceId);
                return new ServicesProvidedNotFoundException(
                    "Service not found with ID: " + serviceId);
            });
    }

    // --- MAPPERS (MODIFIED) ---

    /**
     * (MODIFIED)
     */
    private ServicesProvidedDto toDto(ServicesProvided service) {
        return new ServicesProvidedDto(
                service.getName(),
                service.getDescription(),
                service.getPrice(),
                service.getAvailability(),
                service.getServiceCategory().getId(),
                service.getStartTime(),  // Added
                service.getEndTime()      // Added
        );
    }

    /**
     * (MODIFIED)
     */
    private ServicesProvided toEntity(ServicesProvidedDto dto,
                                      ServiceProvider provider,
                                      ServiceCategory category) {
        return ServicesProvided.builder()
                .name(dto.name())
                .description(dto.description())
                .price(dto.price())
                .availability(dto.availability())
                .serviceProvider(provider)
                .serviceCategory(category)
                .startTime(dto.startTime()) // Added
                .endTime(dto.endTime())     // Added
                .build();
    }
}