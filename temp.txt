// ServicesProvidedController.java
package com.example.demo.controller;

import com.example.demo.dto.ServicesProvidedDto;
import com.example.demo.service.ServicesProvidedService;
import com.example.demo.config.JwtService; // Assuming this is your JwtService package
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/services-provided")
@RequiredArgsConstructor
@Slf4j
public class ServicesProvidedController {

    private final ServicesProvidedService servicesProvidedService;
    private final JwtService jwtService;

    /**
     * POST /api/v1/services-provided : Creates a new service.
     * The provider is identified by their JWT token.
     */
    @PostMapping
    public ResponseEntity<ServicesProvidedDto> addService(
            @RequestHeader("Authorization") String authHeader,
            @Valid @RequestBody ServicesProvidedDto serviceDto) {

        String email = extractEmailFromToken(authHeader);
        ServicesProvidedDto createdService = servicesProvidedService.addService(email, serviceDto);

        // Return 201 Created
        return ResponseEntity.status(HttpStatus.CREATED).body(createdService);
    }

    /**
     * PUT /api/v1/services-provided/{serviceId} : Updates an existing service.
     * Ensures the user updating the service is the one who owns it.
     */
    @PutMapping("/{serviceId}")
    public ResponseEntity<ServicesProvidedDto> updateService(
            @PathVariable Long serviceId,
            @RequestHeader("Authorization") String authHeader,
            @Valid @RequestBody ServicesProvidedDto serviceDto) {

        String email = extractEmailFromToken(authHeader);
        // Assumes service method is: updateService(Long serviceId, ServicesProvidedDto dto, String email)
        ServicesProvidedDto updatedService = servicesProvidedService.updateService(serviceId, serviceDto, email);

        // Return 200 OK
        return ResponseEntity.ok(updatedService);
    }

    /**
     * GET /api/v1/services-provided/{serviceId} : Retrieves a specific service by ID.
     * This is a public endpoint.
     */
    @GetMapping("/{serviceId}")
    public ResponseEntity<ServicesProvidedDto> getServiceById(@PathVariable Long serviceId) {
        ServicesProvidedDto serviceDto = servicesProvidedService.getServiceById(serviceId);

        // Return 200 OK
        return ResponseEntity.ok(serviceDto);
    }

    /**
     * GET /api/v1/services-provided/category/{categoryId} : Retrieves all services
     * for a given category. This is a public endpoint.
     */
    @GetMapping("/category/{categoryId}")
    public ResponseEntity<List<ServicesProvidedDto>> getServicesByCategory(
            @PathVariable Long categoryId) {

        List<ServicesProvidedDto> services = servicesProvidedService.getAllServicesByCategory(categoryId);

        // Return 200 OK
        return ResponseEntity.ok(services);
    }

    /**
     * DELETE /api/v1/services-provided/{serviceId} : Deletes a service.
     * Ensures the user deleting the service is the one who owns it.
     */
    @DeleteMapping("/{serviceId}")
    public ResponseEntity<Void> deleteService(
            @PathVariable Long serviceId,
            @RequestHeader("Authorization") String authHeader) {

        String email = extractEmailFromToken(authHeader);
        // Assumes service method is: deleteService(Long serviceId, String email)
        servicesProvidedService.deleteService(serviceId, email);

        // Return 204 No Content
        return ResponseEntity.noContent().build();
    }


    // --- Private Helper Method ---

    /**
     * Extracts the email from the "Bearer <token>" header.
     */
    private String extractEmailFromToken(String authHeader) {
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            log.warn("Invalid or missing Authorization header.");
            // In a real app, a Spring Security filter would handle this
            // before it even reaches the controller.
            throw new IllegalArgumentException("Invalid Authorization header");
        }
        // Extract token by removing "Bearer " prefix (7 characters)
        String token = authHeader.substring(7);
        return jwtService.extractEmail(token);
    }
}